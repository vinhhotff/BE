"use strict";
/* eslint-disable @typescript-eslint/ban-types */
/**
 * soft-deleted methods: softDeleteOne, softDeleteMany, findByIdAndSoftDelete
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SoftDelete = void 0;
const mongoose_1 = require("mongoose");
const semver = require("semver");
const _ = require("lodash");
const softDeleteMapping = {
    softDeleteOne: 'updateOne',
    softDeleteMany: 'updateMany',
    findByIdAndSoftDelete: 'findByIdAndUpdate',
};
const overriddenMethods = [
    'aggregate',
    // 'bulkSave',
    'bulkWrite',
    'count',
    'countDocuments',
    // 'create',
    // 'deleteMany',
    // 'deleteOne',
    'distinct',
    'exists',
    'find',
    // 'findById',
    // 'findByIdAndDelete',
    // 'findByIdAndRemove',
    // 'findByIdAndUpdate',
    'findOne',
    // 'findOneAndDelete',
    // 'findOneAndRemove',
    'findOneAndReplace',
    'findOneAndUpdate',
    // 'insertMany',
    // 'deleteOne',
    // 'remove',
    // 'save',
    // 'remove',
    'replaceOne',
    'update',
    'updateMany',
    'updateOne',
];
class SoftDelete {
    constructor(options) {
        const { isDeletedField, deletedAtField, mongoDBVersion, override } = options;
        this.isDeletedField = isDeletedField;
        this.deletedAtField = deletedAtField;
        this.mongoDBVersion = mongoDBVersion;
        this.overrideOptions = override || {};
        this.nonDeletedFilterOptions = { [this.isDeletedField]: { $ne: true } };
        this.deleteUpdateOptions = {
            [this.isDeletedField]: true,
            get [this.deletedAtField]() {
                return new Date();
            },
        };
        this.nonDeletedPipelineMatchOptions = {
            $match: this.nonDeletedFilterOptions,
        };
    }
    isLookupStage(stage) {
        return stage.$lookup ? true : false;
    }
    isGraphLookupStage(stage) {
        return stage.$graphLookup ? true : false;
    }
    isIncludeSoftDeleteField(filter) {
        return JSON.stringify(filter).includes(`"${this.isDeletedField}"`);
    }
    getPlugin() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const softDelete = this;
        return (schema) => {
            const softDeleteMethods = Object.keys(softDeleteMapping);
            softDeleteMethods.forEach(softDeleteMethod => {
                schema.statics[softDeleteMethod] = function (...args) {
                    const argsClone = _.cloneDeep(args);
                    const overriddenArgs = [
                        Object.assign(softDeleteMethod === 'findByIdAndSoftDelete'
                            ? { _id: argsClone[0] }
                            : argsClone[0] || {}, softDelete.nonDeletedFilterOptions),
                        { $set: softDelete.deleteUpdateOptions },
                        ...argsClone.slice(1),
                    ];
                    return mongoose_1.Model[softDeleteMapping[softDeleteMethod]].apply(this, overriddenArgs);
                };
            });
            overriddenMethods.forEach(overriddenMethod => {
                if (softDelete.overrideOptions[overriddenMethod] === false) {
                    return;
                }
                schema.statics[overriddenMethod] = function (...args) {
                    const argsClone = _.cloneDeep(args);
                    let overriddenArgs;
                    if (overriddenMethod === 'aggregate') {
                        const pipelineStages = argsClone[0] || [];
                        if (!softDelete.isIncludeSoftDeleteField(pipelineStages)) {
                            pipelineStages.unshift(softDelete.nonDeletedPipelineMatchOptions);
                        }
                        pipelineStages.forEach(stage => {
                            if (softDelete.isLookupStage(stage)) {
                                if (stage.$lookup.pipeline) {
                                    stage.$lookup.pipeline.unshift(softDelete.nonDeletedPipelineMatchOptions);
                                }
                                else {
                                    if (!softDelete.mongoDBVersion ||
                                        semver.gt(softDelete.mongoDBVersion, '5.0.0')) {
                                        stage.$lookup.pipeline = [
                                            ...(stage.$lookup.pipeline || []),
                                            softDelete.nonDeletedPipelineMatchOptions,
                                        ];
                                    }
                                    else {
                                        const letField = 'localField';
                                        stage.$lookup = {
                                            from: stage.$lookup.from,
                                            let: { [letField]: `$${stage.$lookup.localField}` },
                                            pipeline: [
                                                softDelete.nonDeletedPipelineMatchOptions,
                                                {
                                                    $match: {
                                                        $expr: {
                                                            $eq: [
                                                                `$$${letField}`,
                                                                `$${stage.$lookup.foreignField}`,
                                                            ],
                                                        },
                                                    },
                                                },
                                            ],
                                            as: stage.$lookup.as,
                                        };
                                    }
                                }
                            }
                            else if (softDelete.isGraphLookupStage(stage)) {
                                stage.$graphLookup.restrictSearchWithMatch = Object.assign(stage.$graphLookup.restrictSearchWithMatch || {}, softDelete.nonDeletedFilterOptions);
                            }
                        });
                        overriddenArgs = [pipelineStages, ...argsClone.slice(1)];
                    }
                    else if (overriddenMethod === 'bulkWrite') {
                        const writes = argsClone[0];
                        writes.forEach((write) => {
                            const [operation] = Object.keys(write);
                            if (['updateOne', 'updateMany', 'replaceOne'].includes(operation)) {
                                const operationWrite = write[operation];
                                const filter = operationWrite.filter || {};
                                if (!softDelete.isIncludeSoftDeleteField(filter)) {
                                    operationWrite.filter = Object.assign(filter, softDelete.nonDeletedFilterOptions);
                                }
                            }
                        });
                        overriddenArgs = [writes, ...argsClone.slice(1)];
                    }
                    else if (overriddenMethod === 'distinct') {
                        const filter = args[1] || {};
                        if (!softDelete.isIncludeSoftDeleteField(filter)) {
                            Object.assign(filter, softDelete.nonDeletedFilterOptions);
                        }
                        overriddenArgs = [argsClone[0], filter, ...argsClone.slice(2)];
                    }
                    else {
                        const filter = args[0] || {};
                        if (!softDelete.isIncludeSoftDeleteField(filter)) {
                            Object.assign(filter, softDelete.nonDeletedFilterOptions);
                        }
                        overriddenArgs = [filter, ...argsClone.slice(1)];
                    }
                    return mongoose_1.Model[overriddenMethod].apply(this, overriddenArgs);
                };
            });
        };
    }
}
exports.SoftDelete = SoftDelete;
